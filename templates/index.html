<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Streaming App (v2)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />

    <!-- HLS.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <!-- Dash.js -->
    <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
</head>
<body class="bg-gray-100">
    <div class="min-h-screen flex flex-col items-center px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">Video Streaming App (v1)</h1>
        <!-- Upload & Options Card -->
        <div class="w-full max-w-3xl bg-white rounded-lg shadow p-6 mb-6">
            <form id="uploadForm" class="space-y-4">
                <!-- File -->
                <div>
                    <label class="block text-gray-700 mb-2" for="videoFile">Video File</label>
                    <input
                        type="file"
                        id="videoFile"
                        accept="video/*"
                        class="w-full p-2 border rounded"
                        required
                    />
                    <p class="text-xs text-gray-500 mt-1">mp4, mov 등 일반적인 비디오 파일 지원</p>
                </div>

                <!-- Media Format -->
                <div>
                    <div class="flex items-center justify-between mb-2">
                        <span class="block text-gray-700">Media Format</span>
                        <span class="text-xs text-gray-400">선택에 따라 Streaming Protocol 옵션이 자동 변경됩니다</span>
                    </div>
                    <div class="grid grid-cols-2 gap-2 md:grid-cols-4">
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="hls" class="form-radio" checked />
                            <span class="text-sm">HLS (m3u8/ts)</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="ts" class="form-radio" />
                            <span class="text-sm">MPEG-2 TS</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="cmaf" class="form-radio" />
                            <span class="text-sm">CMAF (fMP4, HLS/DASH)</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="dash" class="form-radio" />
                            <span class="text-sm">DASH (fMP4/mpd)</span>
                        </label>
                    </div>
                </div>

                <!-- Streaming Protocol -->
                <div>
                    <span class="block text-gray-700 mb-2">Streaming Protocol</span>
                    <div class="flex flex-wrap gap-3">
                        <label id="labelProtoHLS" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="hls" class="form-radio" checked />
                            <span class="text-sm">HLS</span>
                        </label>
                        <label id="labelProtoDASH" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="dash" class="form-radio" />
                            <span class="text-sm">MPEG-DASH</span>
                        </label>
                        <label id="labelProtoRTSP" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="rtsp" class="form-radio" />
                            <span class="text-sm">RTSP</span>
                        </label>
                    </div>
                    <p class="mt-1 text-xs text-gray-500" id="protoHint"></p>
                </div>

                <!-- Segment Duration -->
                <div>
                    <label class="block text-gray-700 mb-1" for="segmentDuration">Segment Duration (seconds)</label>
                    <input
                        type="number"
                        id="segmentDuration"
                        min="1"
                        value="6"
                        class="w-32 p-2 border rounded text-sm"
                    />
                    <p class="text-xs text-gray-400 mt-1">HLS, DASH, CMAF 모두 이 길이 기준으로 세그먼트가 생성됩니다.</p>
                </div>

                <!-- Encoding Quality -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- CRF -->
                    <div>
                        <label class="block text-gray-700 mb-1" for="crfValue">CRF (Video Quality)</label>
                        <input
                            type="number"
                            id="crfValue"
                            min="16"
                            max="30"
                            value="20"
                            class="w-24 p-2 border rounded text-sm"
                        />
                        <p class="text-xs text-gray-400 mt-1">낮을수록 고화질 (파일 용량 증가). 권장 범위: 18~24.</p>
                    </div>

                    <!-- Resolution -->
                    <div>
                        <span class="block text-gray-700 mb-1">Resolution</span>
                        <div class="flex flex-wrap gap-2 text-xs" id="resolutionGroup">
                            <label class="flex items-center space-x-1 border rounded px-2 py-1 cursor-pointer">
                                <input type="radio" name="resolution" value="source" class="form-radio" checked />
                                <span>Source</span>
                            </label>
                            <label class="flex items-center space-x-1 border rounded px-2 py-1 cursor-pointer">
                                <input type="radio" name="resolution" value="360p" class="form-radio" />
                                <span>360p</span>
                            </label>
                            <label class="flex items-center space-x-1 border rounded px-2 py-1 cursor-pointer">
                                <input type="radio" name="resolution" value="720p" class="form-radio" />
                                <span>720p</span>
                            </label>
                            <label class="flex items-center space-x-1 border rounded px-2 py-1 cursor-pointer">
                                <input type="radio" name="resolution" value="1080p" class="form-radio" />
                                <span>1080p</span>
                            </label>
                        </div>
                        <p class="text-xs text-gray-400 mt-1">해상도를 줄이면 대역폭/용량이 줄어드는 대신 디테일이 감소합니다.</p>
                    </div>
                </div>

                <button
                    type="submit"
                    class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition"
                >
                    Upload & Convert
                </button>
            </form>

            <div id="status" class="mt-4 hidden text-sm"></div>
        </div>

        <!-- Player Area -->
        <div id="playerSection" class="w-full max-w-3xl hidden">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-lg font-semibold mb-3">Player</h2>
                <p id="playerInfo" class="text-xs text-gray-500 mb-2"></p>
                <div class="bg-black rounded overflow-hidden">
                    <video
                        id="videoElement"
                        class="w-full h-auto"
                        controls
                        playsinline
                        preload="auto"
                    ></video>
                </div>
                <!-- Segment navigation bar -->
                <div class="mt-3">
                    <div class="flex items-center justify-between mb-1">
                        <span class="text-xs font-semibold text-gray-700">Current Segment</span>
                        <span id="currentSegmentLabel" class="text-xs text-gray-500">-</span>
                    </div>
                    <div id="segmentBar" class="flex flex-wrap gap-1 text-[10px]"></div>
                </div>
                <p id="rtspInfo" class="text-sm text-gray-200 mt-2 hidden"></p>
            </div>
        </div>
        
        <!-- Modal for viewing raw segment content -->
        <div id="segmentModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 px-4">
            <div class="bg-white rounded-lg shadow-lg max-w-4xl w-full max-h-[80vh] flex flex-col">
                <div class="flex items-center justify-between px-4 py-2 border-b">
                    <h3 class="text-sm font-semibold" id="segmentModalTitle">Segment Content</h3>
                    <button id="segmentModalClose" class="text-gray-500 hover:text-gray-700 text-sm">✕</button>
                </div>
                <div class="p-4 overflow-auto flex-1">
                    <pre id="segmentModalBody" class="text-xs font-mono whitespace-pre-wrap break-all"></pre>
                </div>
                <div class="px-4 py-2 border-t text-xs text-gray-500">
                    Text manifests(m3u8/mpd)는 그대로, 기타 바이너리는 별도 플레이어/도구로 분석하는 것을 권장합니다.
                </div>
            </div>
        </div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const protoHint = document.getElementById('protoHint');
        const playerSection = document.getElementById('playerSection');
        const playerInfo = document.getElementById('playerInfo');
        const rtspInfo = document.getElementById('rtspInfo');
        const videoElement = document.getElementById('videoElement');

        const labelProtoHLS = document.getElementById('labelProtoHLS');
        const labelProtoDASH = document.getElementById('labelProtoDASH');
        const labelProtoRTSP = document.getElementById('labelProtoRTSP');

        function setStatus(type, message) {
            statusDiv.classList.remove('hidden');
            statusDiv.className = 'mt-4 text-sm';
            if (type === 'info') {
                statusDiv.classList.add('text-blue-700', 'bg-blue-50', 'border', 'border-blue-200', 'px-3', 'py-2', 'rounded');
            } else if (type === 'success') {
                statusDiv.classList.add('text-green-700', 'bg-green-50', 'border', 'border-green-200', 'px-3', 'py-2', 'rounded');
            } else if (type === 'error') {
                statusDiv.classList.add('text-red-700', 'bg-red-50', 'border', 'border-red-200', 'px-3', 'py-2', 'rounded');
            }
            statusDiv.textContent = message;
        }

        function resetProtocolRadios() {
            const radios = document.querySelectorAll('input[name="streamingProtocol"]');
            [labelProtoHLS, labelProtoDASH, labelProtoRTSP].forEach(l => {
                l.classList.remove('opacity-50', 'cursor-not-allowed');
            });
            radios.forEach(r => {
                r.disabled = false;
            });
        }

        function updateProtocolByMediaFormat() {
            const mediaFormat = document.querySelector('input[name="mediaFormat"]:checked').value;
            const radios = document.querySelectorAll('input[name="streamingProtocol"]');
            resetProtocolRadios();

            // 기본: 아무것도 선택 안 된 상태로 시작
            radios.forEach(r => { r.checked = false; });

            if (mediaFormat === 'hls') {
                // hls (m3u8/ts) 선택시 streaming 프로토콜은 HLS 버튼만 선택되도록
                radios.forEach(r => {
                    if (r.value === 'hls') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'HLS 포맷은 HLS 프로토콜로만 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'ts') {
                // ts 선택시 RTSP 버튼만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'rtsp') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'TS 포맷은 RTSP 프로토콜로만 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'cmaf') {
                // CMAF 선택시 MPEG-DASH, HLS 버튼만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'dash' || r.value === 'hls') {
                        // 둘 중 기본 선택은 HLS로
                        if (r.value === 'hls') r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'CMAF 포맷은 HLS 또는 MPEG-DASH 프로토콜로 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'dash') {
                // DASH 선택 시 MPEG-DASH만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'dash') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'DASH 포맷은 MPEG-DASH 프로토콜로만 스트리밍할 수 있습니다.';
            }
        }

        document.querySelectorAll('input[name="mediaFormat"]').forEach(r => {
            r.addEventListener('change', updateProtocolByMediaFormat);
        });

        updateProtocolByMediaFormat();

        let currentPlayer = { hls: null, dash: null };
        let segmentHistory = [];
        const maxSegments = 12;
        let segmentCounter = 0; // 전체 세그먼트 순번
        let currentSegmentDuration = 6; // 초 단위, 업로드 시 설정값을 저장

        function clearPlayer() {
            if (currentPlayer.hls) {
                currentPlayer.hls.destroy();
                currentPlayer.hls = null;
            }
            if (currentPlayer.dash) {
                currentPlayer.dash.reset();
                currentPlayer.dash = null;
            }
            videoElement.removeAttribute('src');
            videoElement.load();
            segmentHistory = [];
            segmentCounter = 0;
            renderSegmentBar();
        }

        function addSegment(type, url) {
            if (!url) return;
            const name = url.split('/').pop() || url;
            const seg = { type, url, name, order: segmentCounter++ };
            // 중복 연속 세그먼트는 패스
            if (segmentHistory.length && segmentHistory[segmentHistory.length - 1].name === name) {
                return;
            }
            segmentHistory.push(seg);
            if (segmentHistory.length > maxSegments) {
                segmentHistory.shift();
            }
            renderSegmentBar();
        }

        function renderSegmentBar() {
            const bar = document.getElementById('segmentBar');
            const label = document.getElementById('currentSegmentLabel');
            if (!bar || !label) return;

            if (!segmentHistory.length) {
                bar.innerHTML = '';
                label.textContent = '-';
                return;
            }

            const current = segmentHistory[segmentHistory.length - 1];
            label.textContent = current.name;

            bar.innerHTML = segmentHistory
                .map((seg, idx) => {
                    const isCurrent = idx === segmentHistory.length - 1;
                    return `<button
                        class="px-2 py-0.5 rounded border ${isCurrent ? 'bg-blue-500 text-white border-blue-600' : 'bg-gray-100 text-gray-700 border-gray-300'}"
                        title="${seg.url}"
                        data-order="${seg.order}"
                        type="button"
                    >
                        ${seg.name}
                    </button>`;
                })
                .join('');
        }

        // 세그먼트 바 클릭 시 해당 세그먼트 위치로 시킹
        document.getElementById('segmentBar').addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-order]');
            if (!btn) return;
            const order = parseInt(btn.getAttribute('data-order'), 10);
            if (isNaN(order) || !currentSegmentDuration || !videoElement) return;

            const targetTime = order * currentSegmentDuration;
            try {
                videoElement.currentTime = targetTime;
                videoElement.play().catch(() => {});
            } catch (err) {
                console.error('Failed to seek to segment', err);
            }
        });

        // Segment modal close
        (function initSegmentModal() {
            const modal = document.getElementById('segmentModal');
            const closeBtn = document.getElementById('segmentModalClose');
            if (!modal || !closeBtn) return;

            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
            });
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });
        })();

        function initHlsPlayer(url) {
            clearPlayer();
            if (Hls.isSupported()) {
                const hls = new Hls();
                currentPlayer.hls = hls;
                hls.loadSource(url);
                hls.attachMedia(videoElement);
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoElement.play().catch(console.error);
                });
                hls.on(Hls.Events.FRAG_CHANGED, (event, data) => {
                    if (data && data.frag && data.frag.url) {
                        addSegment('hls', data.frag.url);
                    }
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                videoElement.src = url;
                videoElement.play().catch(console.error);
            } else {
                setStatus('error', '이 브라우저는 HLS를 지원하지 않습니다.');
            }
        }

        function initDashPlayer(url) {
            clearPlayer();
            const player = dashjs.MediaPlayer().create();
            currentPlayer.dash = player;
            player.initialize(videoElement, url, true);
            player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED, function(e) {
                if (e && e.request && e.request.url) {
                    addSegment('dash', e.request.url);
                }
            });
        }

        function showRtspInfo(rtspUrl) {
            clearPlayer();
            rtspInfo.classList.remove('hidden');
            rtspInfo.textContent = `RTSP URL: ${rtspUrl} (VLC 등 외부 플레이어로 재생)`;
        }

        async function pollTaskUntilReady(taskId, streamingProtocol) {
            while (true) {
                const res = await fetch(`/api/v1/tasks/${taskId}`);
                if (!res.ok) throw new Error('Failed to get task status');
                const data = await res.json();
                if (data.status === 'completed') {
                    return;
                }
                if (data.status === 'failed') {
                    throw new Error(data.error || 'Conversion failed');
                }
                await new Promise(r => setTimeout(r, 2000));
            }
        }

        async function loadStreamAndPlay(taskId, streamingProtocol) {
            const res = await fetch(`/api/v1/stream/${taskId}`);
            if (!res.ok) throw new Error('Failed to get stream info');
            const data = await res.json();

            playerSection.classList.remove('hidden');

            if (streamingProtocol === 'hls') {
                const url = data.hls_url;
                if (!url) throw new Error('HLS URL not found');
                playerInfo.textContent = `HLS Streaming: ${url}`;
                initHlsPlayer(url);
            } else if (streamingProtocol === 'dash') {
                const url = data.dash_url;
                if (!url) throw new Error('DASH URL not found');
                playerInfo.textContent = `MPEG-DASH Streaming: ${url}`;
                initDashPlayer(url);
            } else if (streamingProtocol === 'rtsp') {
                const url = data.rtsp_url;
                if (!url) throw new Error('RTSP URL not found');
                playerInfo.textContent = 'RTSP Streaming';
                showRtspInfo(url);
            }
        }

        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const fileInput = document.getElementById('videoFile');
            const file = fileInput.files[0];
            if (!file) {
                setStatus('error', '비디오 파일을 선택해 주세요.');
                return;
            }

            const mediaFormat = document.querySelector('input[name="mediaFormat"]:checked').value;
            const streamingProtocol = document.querySelector('input[name="streamingProtocol"]:checked')?.value;
            if (!streamingProtocol) {
                setStatus('error', 'Streaming Protocol을 선택해 주세요.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('media_format', mediaFormat);
            formData.append('streaming_protocol', streamingProtocol);
            const segInput = document.getElementById('segmentDuration');
            const segVal = segInput && segInput.value ? parseInt(segInput.value, 10) : 6;
            const segDurationToUse = isNaN(segVal) ? 6 : segVal;
            currentSegmentDuration = segDurationToUse;
            formData.append('segment_duration', segDurationToUse);

            // CRF & Resolution
            const crfInput = document.getElementById('crfValue');
            let crfVal = crfInput && crfInput.value ? parseInt(crfInput.value, 10) : 20;
            if (isNaN(crfVal)) crfVal = 20;
            crfVal = Math.min(30, Math.max(16, crfVal));
            formData.append('crf', crfVal);

            const resolutionRadio = document.querySelector('input[name="resolution"]:checked');
            const resolution = resolutionRadio ? resolutionRadio.value : 'source';
            formData.append('resolution', resolution);

            setStatus('info', '업로드 및 변환을 시작합니다...');
            playerSection.classList.remove('hidden');
            playerInfo.textContent = '스트림을 준비 중입니다...';
            rtspInfo.classList.add('hidden');

            try {
                const res = await fetch('/api/v1/upload/', {
                    method: 'POST',
                    body: formData,
                });
                if (!res.ok) {
                    const text = await res.text();
                    throw new Error(text || 'Upload failed');
                }
                const data = await res.json();
                const taskId = data.task_id;

                setStatus('info', '변환 중입니다. 잠시만 기다려 주세요...');

                await pollTaskUntilReady(taskId, streamingProtocol);

                setStatus('success', '변환이 완료되었습니다. 플레이어를 초기화합니다.');

                await loadStreamAndPlay(taskId, streamingProtocol);
            } catch (err) {
                console.error(err);
                setStatus('error', err.message || '오류가 발생했습니다.');
            }
        });
    </script>
</body>
</html>
