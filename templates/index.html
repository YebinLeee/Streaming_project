<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Streaming App (v2)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />

    <!-- HLS.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.4.12/dist/hls.min.js"></script>
    <!-- Dash.js -->
    <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
</head>
<body class="bg-gray-100">
    <div class="min-h-screen flex flex-col items-center px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">Video Streaming App (v2)</h1>

        <!-- Upload & Options Card -->
        <div class="w-full max-w-3xl bg-white rounded-lg shadow p-6 mb-6">
            <form id="uploadForm" class="space-y-4">
                <!-- File -->
                <div>
                    <label class="block text-gray-700 mb-2" for="videoFile">Video File</label>
                    <input
                        type="file"
                        id="videoFile"
                        accept="video/*"
                        class="w-full p-2 border rounded"
                        required
                    />
                    <p class="text-xs text-gray-500 mt-1">mp4, mov 등 일반적인 비디오 파일 지원</p>
                </div>

                <!-- Media Format -->
                <div>
                    <div class="flex items-center justify-between mb-2">
                        <span class="block text-gray-700">Media Format</span>
                        <span class="text-xs text-gray-400">선택에 따라 Streaming Protocol 옵션이 자동 변경됩니다</span>
                    </div>
                    <div class="grid grid-cols-2 gap-2 md:grid-cols-4">
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="hls" class="form-radio" checked />
                            <span class="text-sm">HLS (m3u8/ts)</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="ts" class="form-radio" />
                            <span class="text-sm">TS</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="cmaf" class="form-radio" />
                            <span class="text-sm">CMAF</span>
                        </label>
                        <label class="flex items-center space-x-2 border rounded px-2 py-1 cursor-pointer">
                            <input type="radio" name="mediaFormat" value="dash" class="form-radio" />
                            <span class="text-sm">DASH (fMP4)</span>
                        </label>
                    </div>
                </div>

                <!-- Streaming Protocol -->
                <div>
                    <span class="block text-gray-700 mb-2">Streaming Protocol</span>
                    <div class="flex flex-wrap gap-3">
                        <label id="labelProtoHLS" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="hls" class="form-radio" checked />
                            <span class="text-sm">HLS</span>
                        </label>
                        <label id="labelProtoDASH" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="dash" class="form-radio" />
                            <span class="text-sm">MPEG-DASH</span>
                        </label>
                        <label id="labelProtoRTSP" class="flex items-center space-x-2 border rounded px-3 py-1 cursor-pointer">
                            <input type="radio" name="streamingProtocol" value="rtsp" class="form-radio" />
                            <span class="text-sm">RTSP</span>
                        </label>
                    </div>
                    <p class="mt-1 text-xs text-gray-500" id="protoHint"></p>
                </div>

                <button
                    type="submit"
                    class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition"
                >
                    Upload & Convert
                </button>
            </form>

            <div id="status" class="mt-4 hidden text-sm"></div>
        </div>

        <!-- Player Area -->
        <div id="playerSection" class="w-full max-w-3xl hidden">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-lg font-semibold mb-3">Player</h2>
                <p id="playerInfo" class="text-xs text-gray-500 mb-2"></p>
                <div class="bg-black rounded overflow-hidden">
                    <video
                        id="videoElement"
                        class="w-full h-auto"
                        controls
                        playsinline
                        preload="auto"
                    ></video>
                </div>
                <p id="rtspInfo" class="text-sm text-gray-200 mt-2 hidden"></p>
            </div>
        </div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const protoHint = document.getElementById('protoHint');
        const playerSection = document.getElementById('playerSection');
        const playerInfo = document.getElementById('playerInfo');
        const rtspInfo = document.getElementById('rtspInfo');
        const videoElement = document.getElementById('videoElement');

        const labelProtoHLS = document.getElementById('labelProtoHLS');
        const labelProtoDASH = document.getElementById('labelProtoDASH');
        const labelProtoRTSP = document.getElementById('labelProtoRTSP');

        function setStatus(type, message) {
            statusDiv.classList.remove('hidden');
            statusDiv.className = 'mt-4 text-sm';
            if (type === 'info') {
                statusDiv.classList.add('text-blue-700', 'bg-blue-50', 'border', 'border-blue-200', 'px-3', 'py-2', 'rounded');
            } else if (type === 'success') {
                statusDiv.classList.add('text-green-700', 'bg-green-50', 'border', 'border-green-200', 'px-3', 'py-2', 'rounded');
            } else if (type === 'error') {
                statusDiv.classList.add('text-red-700', 'bg-red-50', 'border', 'border-red-200', 'px-3', 'py-2', 'rounded');
            }
            statusDiv.textContent = message;
        }

        function resetProtocolRadios() {
            const radios = document.querySelectorAll('input[name="streamingProtocol"]');
            [labelProtoHLS, labelProtoDASH, labelProtoRTSP].forEach(l => {
                l.classList.remove('opacity-50', 'cursor-not-allowed');
            });
            radios.forEach(r => {
                r.disabled = false;
            });
        }

        function updateProtocolByMediaFormat() {
            const mediaFormat = document.querySelector('input[name="mediaFormat"]:checked').value;
            const radios = document.querySelectorAll('input[name="streamingProtocol"]');
            resetProtocolRadios();

            // 기본: 아무것도 선택 안 된 상태로 시작
            radios.forEach(r => { r.checked = false; });

            if (mediaFormat === 'hls') {
                // hls (m3u8/ts) 선택시 streaming 프로토콜은 HLS 버튼만 선택되도록
                radios.forEach(r => {
                    if (r.value === 'hls') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'HLS 포맷은 HLS 프로토콜로만 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'ts') {
                // ts 선택시 RTSP 버튼만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'rtsp') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'TS 포맷은 RTSP 프로토콜로만 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'cmaf') {
                // CMAF 선택시 MPEG-DASH, HLS 버튼만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'dash' || r.value === 'hls') {
                        // 둘 중 기본 선택은 HLS로
                        if (r.value === 'hls') r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'CMAF 포맷은 HLS 또는 MPEG-DASH 프로토콜로 스트리밍할 수 있습니다.';
            } else if (mediaFormat === 'dash') {
                // DASH 선택 시 MPEG-DASH만 활성화되도록
                radios.forEach(r => {
                    if (r.value === 'dash') {
                        r.checked = true;
                    } else {
                        r.disabled = true;
                        const label = r.closest('label');
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                protoHint.textContent = 'DASH 포맷은 MPEG-DASH 프로토콜로만 스트리밍할 수 있습니다.';
            }
        }

        document.querySelectorAll('input[name="mediaFormat"]').forEach(r => {
            r.addEventListener('change', updateProtocolByMediaFormat);
        });

        updateProtocolByMediaFormat();

        let currentPlayer = { hls: null, dash: null };

        function clearPlayer() {
            if (currentPlayer.hls) {
                currentPlayer.hls.destroy();
                currentPlayer.hls = null;
            }
            if (currentPlayer.dash) {
                currentPlayer.dash.reset();
                currentPlayer.dash = null;
            }
            videoElement.removeAttribute('src');
            videoElement.load();
        }

        function initHlsPlayer(url) {
            clearPlayer();
            if (Hls.isSupported()) {
                const hls = new Hls();
                currentPlayer.hls = hls;
                hls.loadSource(url);
                hls.attachMedia(videoElement);
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    videoElement.play().catch(console.error);
                });
            } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {
                videoElement.src = url;
                videoElement.play().catch(console.error);
            } else {
                setStatus('error', '이 브라우저는 HLS를 지원하지 않습니다.');
            }
        }

        function initDashPlayer(url) {
            clearPlayer();
            const player = dashjs.MediaPlayer().create();
            currentPlayer.dash = player;
            player.initialize(videoElement, url, true);
        }

        function showRtspInfo(rtspUrl) {
            clearPlayer();
            rtspInfo.classList.remove('hidden');
            rtspInfo.textContent = `RTSP URL: ${rtspUrl} (VLC 등 외부 플레이어로 재생)`;
        }

        async function pollTaskUntilReady(taskId, streamingProtocol) {
            while (true) {
                const res = await fetch(`/api/v1/tasks/${taskId}`);
                if (!res.ok) throw new Error('Failed to get task status');
                const data = await res.json();
                if (data.status === 'completed') {
                    return;
                }
                if (data.status === 'failed') {
                    throw new Error(data.error || 'Conversion failed');
                }
                await new Promise(r => setTimeout(r, 2000));
            }
        }

        async function loadStreamAndPlay(taskId, streamingProtocol) {
            const res = await fetch(`/api/v1/stream/${taskId}`);
            if (!res.ok) throw new Error('Failed to get stream info');
            const data = await res.json();

            playerSection.classList.remove('hidden');

            if (streamingProtocol === 'hls') {
                const url = data.hls_url;
                if (!url) throw new Error('HLS URL not found');
                playerInfo.textContent = `HLS Streaming: ${url}`;
                initHlsPlayer(url);
            } else if (streamingProtocol === 'dash') {
                const url = data.dash_url;
                if (!url) throw new Error('DASH URL not found');
                playerInfo.textContent = `MPEG-DASH Streaming: ${url}`;
                initDashPlayer(url);
            } else if (streamingProtocol === 'rtsp') {
                const url = data.rtsp_url;
                if (!url) throw new Error('RTSP URL not found');
                playerInfo.textContent = 'RTSP Streaming';
                showRtspInfo(url);
            }
        }

        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const fileInput = document.getElementById('videoFile');
            const file = fileInput.files[0];
            if (!file) {
                setStatus('error', '비디오 파일을 선택해 주세요.');
                return;
            }

            const mediaFormat = document.querySelector('input[name="mediaFormat"]:checked').value;
            const streamingProtocol = document.querySelector('input[name="streamingProtocol"]:checked')?.value;
            if (!streamingProtocol) {
                setStatus('error', 'Streaming Protocol을 선택해 주세요.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('media_format', mediaFormat);
            formData.append('streaming_protocol', streamingProtocol);

            setStatus('info', '업로드 및 변환을 시작합니다...');
            playerSection.classList.remove('hidden');
            playerInfo.textContent = '스트림을 준비 중입니다...';
            rtspInfo.classList.add('hidden');

            try {
                const res = await fetch('/api/v1/upload/', {
                    method: 'POST',
                    body: formData,
                });
                if (!res.ok) {
                    const text = await res.text();
                    throw new Error(text || 'Upload failed');
                }
                const data = await res.json();
                const taskId = data.task_id;

                setStatus('info', '변환 중입니다. 잠시만 기다려 주세요...');

                await pollTaskUntilReady(taskId, streamingProtocol);

                setStatus('success', '변환이 완료되었습니다. 플레이어를 초기화합니다.');

                await loadStreamAndPlay(taskId, streamingProtocol);
            } catch (err) {
                console.error(err);
                setStatus('error', err.message || '오류가 발생했습니다.');
            }
        });
    </script>
</body>
</html>
